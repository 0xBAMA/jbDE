// ollj edit to get backface hits

// ollj, 2023-03-21
// yes

// t == t_min as this always returns the nearest intersection (this is a ray-origin == camera-position case)

// //this one returns the far intersection (or -1 if there is none)
// // intersect capsule : https://iquilezles.org/articles/intersectors
// //modified to return the FAR intersection (with flipped surface normal)
// float capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r ){
//     vec3  ba = pb - pa;
//     vec3  oa = ro - pa;
//     float baba = dot(ba,ba);
//     float bard = dot(ba,rd);
//     float baoa = dot(ba,oa);
//     float rdoa = dot(rd,oa);
//     float oaoa = dot(oa,oa);
//     float a = baba      - bard*bard;
//     float b = baba*rdoa - baoa*bard;
//     float c = baba*oaoa - baoa*baoa - r*r*baba;
//     float h = b*b - a*c;
//     if( h>=0.0 ){
//         float t = (-b+sqrt(h))/a;//changed line
//         float y = baoa + t*bard;        // body
//         if( y>0.0 && y<baba ) return t;     // caps
//         vec3 oc = (y<=0.0) ? oa : ro - pb;
//         b = dot(rd,oc);
//         c = dot(oc,oc) - r*r;
//         h = b*b - c;
//         if( h>0.0 ) return -b + sqrt(h);//changed line
//     }return -1.0;}


// original code from iq
// https://www.shadertoy.com/view/Xt3SzX
// intersect capsule : https://iquilezles.org/articles/intersectors
float capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )
{
    vec3  ba = pb - pa;
    vec3  oa = ro - pa;

    float baba = dot(ba,ba);
    float bard = dot(ba,rd);
    float baoa = dot(ba,oa);
    float rdoa = dot(rd,oa);
    float oaoa = dot(oa,oa);

    float a = baba      - bard*bard;
    float b = baba*rdoa - baoa*bard;
    float c = baba*oaoa - baoa*baoa - r*r*baba;
    float h = b*b - a*c;
    if( h>=0.0 )
    {
        float t = (-b-sqrt(h))/a;
        float y = baoa + t*bard;
        // body
        if( y>0.0 && y<baba ) return t;
        // caps
        vec3 oc = (y<=0.0) ? oa : ro - pb;
        b = dot(rd,oc);
        c = dot(oc,oc) - r*r;
        h = b*b - c;
        if( h>0.0 ) return -b - sqrt(h);
    }
    return -1.0;
}

// compute normal
vec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )
{
    vec3  ba = b - a;
    vec3  pa = pos - a;
    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);
    return (pa - h*ba)/r;
}
